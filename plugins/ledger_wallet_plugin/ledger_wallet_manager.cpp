//// Created by Taras Shchybovyk on 6/11/18.//#include <eosio/ledger_wallet_plugin/ledger_wallet_manager.hpp>#include <eosio/chain/exceptions.hpp>#include <thread>namespace eosio {void ledger_wallet_manager::set_dir(const boost::filesystem::path& p) {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger does not support this operation");}void ledger_wallet_manager::set_timeout(const std::chrono::seconds& t) {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger does not support this operation");}void ledger_wallet_manager::set_timeout(int64_t secs) {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger does not support this operation");}void ledger_wallet_manager::set_eosio_key(const std::string& key) {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger does not support this operation");}std::string ledger_wallet_manager::create(const std::string& name) {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger does not support this operation");    return "";}void ledger_wallet_manager::open(const std::string& name) {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger does not support this operation");}std::vector<std::string> ledger_wallet_manager::list_wallets() {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger does not support this operation");    return vector<std::string>();}map<public_key_type,private_key_type> ledger_wallet_manager::list_keys(const string& name, const string& pw) {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger does not support this operation");    return map<public_key_type, private_key_type>();}void ledger_wallet_manager::lock_all() {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger does not support this operation");}void ledger_wallet_manager::lock(const std::string& name) {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger does not support this operation");}void ledger_wallet_manager::unlock(const std::string& name, const std::string& password) {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger does not support this operation");}void ledger_wallet_manager::import_key(const std::string& name, const std::string& wif_key) {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger does not support this operation");}string ledger_wallet_manager::create_key(const std::string& name, const std::string& key_type) {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger does not support this operation");    return "";}chain::signed_transaction ledger_wallet_manager::sign_transaction(const chain::signed_transaction& txn, const flat_set<public_key_type>& keys,                                           const chain::chain_id_type& id) {    chain::signed_transaction stxn(txn);    // get eos key    private_key_type eosio_priv(eosio_key);    public_key_type eosio_pub = eosio_priv.get_public_key();    for (const auto& pk : keys) {        if (pk == eosio_pub) {            stxn.sign(eosio_priv, id);            break;        } else {            EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger signing not realized");        }        EOS_THROW(chain::wallet_missing_pub_key_exception, "Public key not found in unlocked wallets ${k}", ("k", pk));    }    return stxn;}chain::signature_type ledger_wallet_manager::sign_digest(const chain::digest_type& digest, const public_key_type& key) {    EOS_THROW(chain::wallet_missing_pub_key_exception, "Ledger signing not realized");    return chain::signature_type();}flat_set<public_key_type> ledger_wallet_manager::get_public_keys() {    hid* device = open_device();    auto buffer = hex_to_databuf("8004000000");    auto key = exchange(device, buffer);    close_device(device);    ilog( "Public Key ${c}", ("c",databuf_to_hex(key)) );    auto data = get_compressed_pub_for_key(key);    public_key_type pub_key;    memcpy(&pub_key, data.data, 33);    private_key_type priv(eosio_key);    flat_set<public_key_type> result;    result.insert(priv.get_public_key());    result.insert(pub_key);    return result;}fc::ecc::public_key_data ledger_wallet_manager::get_compressed_pub_for_key(databuf_t key) {    fc::ecc::public_key_data pub_key_data;    const unsigned char* data = key.data();    memcpy(pub_key_data.data+1, data+1, 32);    pub_key_data.data[0] = 0x02;    return pub_key_data;}hid *ledger_wallet_manager::open_device() {    hid *_hid = new hid(0x2c97, 0x01, nullptr);    _hid->set_non_blocking(1);    return _hid;}void ledger_wallet_manager::close_device(eosio::hid *device) {    delete device;}databuf_t ledger_wallet_manager::exchange(hid *device, eosio::databuf_t &apdu) {    auto apdu_buffer = wrap_apdu_command(0x0101, apdu, 64);    auto pad_size = apdu_buffer.size() % 64;    auto temp = apdu_buffer;    if (pad_size != 0) {        temp.insert(temp.end(), (64 - pad_size), 0);    }    unsigned int offset = 0;    while (offset != temp.size()) {        auto data = databuf_t(temp.cbegin() + offset, temp.cbegin() + offset + 64);        data.insert(data.begin(), 0x00);        ilog( "===> ${c}", ("c",databuf_to_hex(data)) );        device->write(data);        offset += 64;    }    size_t data_length = 0;    size_t data_start = 2;    size_t sw_offset = 0;    auto result = wait_first_response(device);    ilog( "<=== ${c}", ("c",databuf_to_hex(result)) );    device->set_non_blocking(0);    databuf_t response;    while (true) {        response = unwrap_apdu_response(0x0101, result, 64);        if (!response.empty()) {            result = response;            ilog( "<=== ${c}", ("c",databuf_to_hex(result)) );            data_start = 0;            sw_offset = response.size() - 2;            data_length = response.size() - 2;            device->set_non_blocking(1);            break;        }        auto new_data = device->read(65);        result.insert(result.end(), new_data.begin(), new_data.end());        ilog( "<=== ${c}", ("c",databuf_to_hex(result)) );    }    unsigned short sw = (((unsigned short)result[sw_offset]) << 8) + result[sw_offset + 1];    response = databuf_t(result.begin() + data_start, result.begin() + data_start + data_length);    if (sw != 0x9000) {        FC_THROW("Ledger Invalid status ${s}", ("s", sw));    }    return response;}databuf_t ledger_wallet_manager::wait_first_response(eosio::hid *device, std::chrono::seconds timeout) {    const auto& start = std::chrono::system_clock::now();    databuf_t data;    while (data.size() == 0) {        data = device->read(65);        if (data.size() == 0) {            const auto& now = std::chrono::system_clock::now();            if (now - start > timeout) {                FC_THROW("Ledger read timeout");            }            std::this_thread::sleep_for(1ms);        }    }    return data;}databuf_t ledger_wallet_manager::wrap_apdu_command(unsigned short channel, eosio::databuf_t &command, unsigned int packet_size) {    if (packet_size < 3) {        FC_THROW("Can't handle Ledger framing with less than 3 bytes for the report");    }    unsigned short sequence_idx = 0;    unsigned int offset = 0;    unsigned short command_length = command.size();    size_t block_size = 0;    databuf_t buffer;    pack_short_be(buffer, channel);    size_t extra_header_size = buffer.size();    pack_byte_be(buffer, 0x05);    pack_short_be(buffer, sequence_idx);    pack_short_be(buffer, command_length);    ++sequence_idx;    if (command_length > packet_size - 5 - extra_header_size) {        block_size = packet_size - 5 - extra_header_size;    } else {        block_size = command_length;    }    pack_buffer(buffer, command, offset, block_size);    offset += block_size;    while (offset != command_length) {        pack_short_be(buffer, channel);        pack_byte_be(buffer, 0x05);        pack_short_be(buffer, sequence_idx);        ++sequence_idx;        if (command_length - offset > packet_size - 3 - extra_header_size) {            block_size = packet_size - 3 - extra_header_size;        } else {            block_size = command_length - offset;        }        pack_buffer(buffer, command, offset, block_size);        offset += block_size;    }    while (buffer.size() % packet_size != 0) {        pack_byte_be(buffer, (unsigned char)0x00);    }    return buffer;}databuf_t ledger_wallet_manager::unwrap_apdu_response(unsigned short channel, eosio::databuf_t &data,                                                          unsigned int packet_size) {    unsigned short sequence_idx = 0;    size_t offset = 0;    size_t block_size = 0;    unsigned int extra_header_size = 2;    if (data.size() < 5 + extra_header_size + 5) {        return databuf_t();    }    if (unpack_short_be(data, offset) != channel) {        FC_THROW("Invalid channel ${c}", ("c", unpack_short_be(data, offset)));    }    offset += 2;    if (unpack_byte_be(data, offset) != 0x05) {        FC_THROW("Invalid tag ${c}", ("c", unpack_byte_be(data, offset)));    }    offset += 1;    if (unpack_short_be(data, offset) != sequence_idx) {        FC_THROW("Invalid sequence ${c}", ("c", unpack_short_be(data, offset)));    }    offset += 2;    unsigned long response_length = unpack_short_be(data, offset);    offset += 2;    if (data.size() < 5 + extra_header_size + response_length) {        return databuf_t();    }    if (response_length > packet_size - 5 - extra_header_size) {        block_size = packet_size - 5 - extra_header_size;    } else {        block_size = response_length;    }    auto result = databuf_t(data.cbegin() + offset, data.cbegin() + offset + block_size);    ilog( "<=== ${c}", ("c",databuf_to_hex(result)) );    offset += block_size;    while (result.size() != response_length) {        ++sequence_idx;        if (offset == data.size()) {            return databuf_t();        }        if (unpack_short_be(data, offset) != channel) {            FC_THROW("Invalid channel ${c}", ("c", unpack_short_be(data, offset)));        }        offset += 2;        if (unpack_byte_be(data, offset) != 0x05) {            FC_THROW("Invalid tag ${c}", ("c", unpack_byte_be(data, offset)));        }        offset += 1;        if (unpack_short_be(data, offset) != sequence_idx) {            FC_THROW("Invalid sequence ${c}", ("c", unpack_short_be(data, offset)));        }        offset += 2;        if (response_length - result.size() > packet_size - 3 - extra_header_size) {            block_size = packet_size - 3 - extra_header_size;        } else {            block_size = response_length - result.size();        }        result.insert(result.end(), data.begin() + offset, data.begin() + offset + block_size);        offset += block_size;    }    return result;}}