//// Created by Taras Shchybovyk on 6/11/18.//#include <eosio/ledger_wallet_plugin/ledger_wallet_manager.hpp>#include <thread>namespace eosio {chain::signed_transaction ledger_wallet_manager::sign_transaction(const chain::signed_transaction& txn, const flat_set<public_key_type>& keys,                                           const chain::chain_id_type& id) {    return chain::signed_transaction();}chain::signature_type ledger_wallet_manager::sign_digest(const chain::digest_type& digest, const public_key_type& key) {    return chain::signature_type();}flat_set<public_key_type> ledger_wallet_manager::get_public_keys() {    hid* device = open_device();    auto buffer = hex_to_bytes("8004000000");    exchange(device, buffer);    close_device(device);    return flat_set<public_key_type>();}hid *ledger_wallet_manager::open_device() {    hid *_hid = new hid(0x2c97, 0x01, nullptr);    _hid->set_non_blocking(1);    return _hid;}void ledger_wallet_manager::close_device(eosio::hid *device) {    delete device;}hid::databuf_t ledger_wallet_manager::hex_to_bytes(const std::string& hex) {    hid::databuf_t bytes;    for (unsigned int i = 0; i < hex.length(); i += 2) {        std::string byteString = hex.substr(i, 2);        unsigned char byte = (unsigned char) strtol(byteString.c_str(), nullptr, 16);        bytes.push_back(byte);    }    return bytes;}hid::databuf_t ledger_wallet_manager::exchange(hid *device, eosio::hid::databuf_t &apdu) {    auto apdu_buffer = wrap_apdu_command(0x0101, apdu, 64);    unsigned int pad_size = apdu_buffer.size() % 64;    auto temp = apdu_buffer;    if (pad_size != 0) {        temp.insert(temp.end(), (64 - pad_size), 0);    }    unsigned int offset = 0;    while (offset != temp.size()) {        auto data = hid::databuf_t(temp.cbegin() + offset, temp.cbegin() + offset + 64 + 1);        data.insert(data.begin(), 0x00);        device->write(data);        offset += 64;    }    unsigned int data_length = 0;    unsigned int data_start = 2;    unsigned int sw_offset = 0;    auto result = wait_first_response(device);    device->set_non_blocking(0);    hid::databuf_t response;    while (true) {        response = unwrap_apdu_response(0x0101, result, 64);        if (response.size() > 0) {            result = response;            data_start = 0;            sw_offset = response.size() - 2;            data_length = response.size() - 2;            device->set_non_blocking(1);            break;        }        auto new_data = device->read(65);        result.insert(result.begin(), new_data.begin(), new_data.end());    }    unsigned short sw = ((unsigned short)(result[sw_offset] << 8)) + ((unsigned short)(result[sw_offset + 1]));    response = hid::databuf_t(result.begin() + data_start, result.begin() + data_start + data_length);    if (sw != 0x9000) {        // THROW Invalid Status    }    return response;}hid::databuf_t ledger_wallet_manager::wait_first_response(eosio::hid *device, std::chrono::seconds timeout) {    const auto& start = std::chrono::system_clock::now();    hid::databuf_t data;    while (data.size() == 0) {        data = device->read(65);        if (data.size() == 0) {            const auto& now = std::chrono::system_clock::now();            if (now - start > timeout) {                // THROW            }            std::this_thread::sleep_for(1ms);        }    }    return data;}hid::databuf_t ledger_wallet_manager::wrap_apdu_command(unsigned short channel, eosio::hid::databuf_t &command, unsigned int packet_size) {    if (packet_size < 3) {        // THRROW "Can't handle Ledger framing with less than 3 bytes for the report"    }    unsigned short sequence_idx = 0;    unsigned int offset = 0;    unsigned int command_length = command.size();    unsigned int block_size = 0;    hid::databuf_t buffer;    buffer.push_back((unsigned char)(channel >> 8));    buffer.push_back((unsigned char)(channel & 0xFF));    unsigned int extra_header_size = buffer.size();    buffer.push_back(0x05);    buffer.push_back((unsigned char)(sequence_idx >> 8));    buffer.push_back((unsigned char)(sequence_idx & 0xFF));    buffer.push_back((unsigned char)(command_length >> 8));    buffer.push_back((unsigned char)(command_length & 0xFF));    ++sequence_idx;    if (command_length > packet_size - 5 - extra_header_size) {        block_size = packet_size - 5 - extra_header_size;    } else {        block_size = command_length;    }    buffer.insert(buffer.end(), command.begin() + offset, command.begin() + block_size);    offset += block_size;    while (offset != command_length) {        buffer.push_back((unsigned char)(channel >> 8));        buffer.push_back((unsigned char)(channel & 0xFF));        buffer.push_back(0x05);        buffer.push_back((unsigned char)(sequence_idx >> 8));        buffer.push_back((unsigned char)(sequence_idx & 0xFF));        ++sequence_idx;        if (command_length - offset > packet_size - 3 - extra_header_size) {            block_size = packet_size - 3 - extra_header_size;        } else {            block_size = command_length - offset;        }        buffer.insert(buffer.end(), command.begin() + offset, command.begin() + block_size);        offset += block_size;    }    while (buffer.size() % packet_size != 0) {        buffer.push_back(0x00);    }    return buffer;}hid::databuf_t ledger_wallet_manager::unwrap_apdu_response(unsigned short channel, eosio::hid::databuf_t &data,                                                          unsigned int packet_size) {    unsigned short sequence_idx = 0;    unsigned int offset = 0;    unsigned int block_size = 0;    unsigned int extra_header_size = 2;    if (data.size() < 5 + extra_header_size + 5) {        return hid::databuf_t();    }    unsigned short unwrapped_channel = ((unsigned short)(data[offset + 1] << 8)) | (unsigned short)data[offset];    if (unwrapped_channel != channel) {        // THORW Invalid channel    }    offset += 2;    if (data[offset] != 0x05) {        // THROW invalid tag    }    offset += 1;    unsigned short unwrapped_sequence_idx = ((unsigned short)(data[offset + 1] << 8)) | (unsigned short)data[offset];    if (unwrapped_sequence_idx != sequence_idx) {        // THROW Invalid sequence    }    offset += 2;    unsigned short response_length = ((unsigned short)(data[offset + 1] << 8)) | (unsigned short)data[offset];    offset += 2;    if (data.size() < 5 + extra_header_size + response_length) {        return hid::databuf_t();    }    if (response_length > packet_size - 5 - extra_header_size) {        block_size = packet_size - 5 - extra_header_size;    } else {        block_size = response_length;    }    auto result = hid::databuf_t(data.cbegin() + offset, data.cbegin() + offset + block_size + 1);    offset += block_size;    while (result.size() != response_length) {        ++sequence_idx;        if (offset == data.size()) {            return hid::databuf_t();        }        unsigned short unwrapped_channel = ((unsigned short)(data[offset + 1] << 8)) | (unsigned short)data[offset];        if (unwrapped_channel != channel) {            // THROW Invalid channel        }        offset += 2;        if (data[offset] != 0x05) {            // THROW invalid tag        }        offset += 1;        unsigned short unwrapped_sequence_idx = ((unsigned short)(data[offset + 1] << 8)) | (unsigned short)data[offset];        if (unwrapped_sequence_idx != sequence_idx) {            // THROW Invalid sequence        }        offset += 2;        if (response_length - result.size() > packet_size - 3 - extra_header_size) {            block_size = packet_size - 3 - extra_header_size;        } else {            block_size = response_length - result.size();        }        result.insert(result.begin(), data.begin() + offset, data.begin() + offset + block_size);        offset += block_size;    }    return result;}}