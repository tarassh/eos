//// Created by Taras Shchybovyk on 6/11/18.//#include <eosio/ledger_wallet_plugin/ledger_wallet_manager.hpp>#include <thread>namespace eosio {chain::signed_transaction ledger_wallet_manager::sign_transaction(const chain::signed_transaction& txn, const flat_set<public_key_type>& keys,                                           const chain::chain_id_type& id) {    return chain::signed_transaction();}chain::signature_type ledger_wallet_manager::sign_digest(const chain::digest_type& digest, const public_key_type& key) {    return chain::signature_type();}flat_set<public_key_type> ledger_wallet_manager::get_public_keys() {    hid* device = open_device();    auto buffer = hex_to_databuf("8004000000");    exchange(device, buffer);    close_device(device);    return flat_set<public_key_type>();}hid *ledger_wallet_manager::open_device() {    hid *_hid = new hid(0x2c97, 0x01, nullptr);    _hid->set_non_blocking(1);    return _hid;}void ledger_wallet_manager::close_device(eosio::hid *device) {    delete device;}databuf_t ledger_wallet_manager::exchange(hid *device, eosio::databuf_t &apdu) {    auto apdu_buffer = wrap_apdu_command(0x0101, apdu, 64);    auto pad_size = apdu_buffer.size() % 64;    auto temp = apdu_buffer;    if (pad_size != 0) {        temp.insert(temp.end(), (64 - pad_size), 0);    }    unsigned int offset = 0;    while (offset != temp.size()) {        auto data = databuf_t(temp.cbegin() + offset, temp.cbegin() + offset + 64);        data.insert(data.begin(), 0x00);        device->write(data);        offset += 64;    }    size_t data_length = 0;    size_t data_start = 2;    size_t sw_offset = 0;    auto result = wait_first_response(device);    device->set_non_blocking(0);    databuf_t response;    while (true) {        response = unwrap_apdu_response(0x0101, result, 64);        if (!response.empty()) {            result = response;            data_start = 0;            sw_offset = response.size() - 2;            data_length = response.size() - 2;            device->set_non_blocking(1);            break;        }        auto new_data = device->read(65);        result.insert(result.begin(), new_data.begin(), new_data.end());    }    unsigned short sw = ((unsigned short)(result[sw_offset] << 8)) | ((unsigned short)(result[sw_offset + 1]));    response = databuf_t(result.begin() + data_start, result.begin() + data_start + data_length);    if (sw != 0x9000) {        // THROW Invalid Status    }    return response;}databuf_t ledger_wallet_manager::wait_first_response(eosio::hid *device, std::chrono::seconds timeout) {    const auto& start = std::chrono::system_clock::now();    databuf_t data;    while (data.size() == 0) {        data = device->read(65);        if (data.size() == 0) {            const auto& now = std::chrono::system_clock::now();            if (now - start > timeout) {                // THROW            }            std::this_thread::sleep_for(1ms);        }    }    return data;}databuf_t ledger_wallet_manager::wrap_apdu_command(unsigned short channel, eosio::databuf_t &command, unsigned int packet_size) {    if (packet_size < 3) {        // THRROW "Can't handle Ledger framing with less than 3 bytes for the report"    }    unsigned short sequence_idx = 0;    unsigned int offset = 0;    unsigned short command_length = command.size();    size_t block_size = 0;    databuf_t buffer;    pack_back_short_be(buffer, channel);    size_t extra_header_size = buffer.size();    pack_back_byte_be(buffer, 0x05);    pack_back_short_be(buffer, sequence_idx);    pack_back_short_be(buffer, command_length);    ++sequence_idx;    if (command_length > packet_size - 5 - extra_header_size) {        block_size = packet_size - 5 - extra_header_size;    } else {        block_size = command_length;    }    pack_back_buffer(buffer, command, offset, block_size);    offset += block_size;    while (offset != command_length) {        pack_back_short_be(buffer, channel);        pack_back_byte_be(buffer, 0x05);        pack_back_short_be(buffer, sequence_idx);        ++sequence_idx;        if (command_length - offset > packet_size - 3 - extra_header_size) {            block_size = packet_size - 3 - extra_header_size;        } else {            block_size = command_length - offset;        }        pack_back_buffer(buffer, command, offset, block_size);        offset += block_size;    }    while (buffer.size() % packet_size != 0) {        pack_back_byte_be(buffer, (unsigned char)0x00);    }    ilog( "Wrapped buffer: ${c}", ("c",databuf_to_hex(buffer)) );    return buffer;}databuf_t ledger_wallet_manager::unwrap_apdu_response(unsigned short channel, eosio::databuf_t &data,                                                          unsigned int packet_size) {    ilog( "data to unwrap: ${c}", ("c",databuf_to_hex(data)) );    unsigned short sequence_idx = 0;    unsigned int offset = 0;    unsigned int block_size = 0;    unsigned int extra_header_size = 2;    if (data.size() < 5 + extra_header_size + 5) {        return databuf_t();    }    unsigned short unwrapped_channel = ((unsigned short)(data[offset + 1] << 8)) | (unsigned short)data[offset];    if (unwrapped_channel != channel) {        // THORW Invalid channel    }    offset += 2;    if (data[offset] != 0x05) {        // THROW invalid tag    }    offset += 1;    unsigned short unwrapped_sequence_idx = ((unsigned short)(data[offset + 1] << 8)) | (unsigned short)data[offset];    if (unwrapped_sequence_idx != sequence_idx) {        // THROW Invalid sequence    }    offset += 2;    unsigned short response_length = ((unsigned short)(data[offset + 1] << 8)) | (unsigned short)data[offset];    offset += 2;    if (data.size() < 5 + extra_header_size + response_length) {        return databuf_t();    }    if (response_length > packet_size - 5 - extra_header_size) {        block_size = packet_size - 5 - extra_header_size;    } else {        block_size = response_length;    }    auto result = databuf_t(data.cbegin() + offset, data.cbegin() + offset + block_size + 1);    offset += block_size;    while (result.size() != response_length) {        ++sequence_idx;        if (offset == data.size()) {            return databuf_t();        }        unsigned short unwrapped_channel = ((unsigned short)(data[offset + 1] << 8)) | (unsigned short)data[offset];        if (unwrapped_channel != channel) {            // THROW Invalid channel        }        offset += 2;        if (data[offset] != 0x05) {            // THROW invalid tag        }        offset += 1;        unsigned short unwrapped_sequence_idx = ((unsigned short)(data[offset + 1] << 8)) | (unsigned short)data[offset];        if (unwrapped_sequence_idx != sequence_idx) {            // THROW Invalid sequence        }        offset += 2;        if (response_length - result.size() > packet_size - 3 - extra_header_size) {            block_size = packet_size - 3 - extra_header_size;        } else {            block_size = response_length - result.size();        }        result.insert(result.begin(), data.begin() + offset, data.begin() + offset + block_size);        offset += block_size;    }    return result;}}